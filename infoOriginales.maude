***( Archivo con la información de los modelos originales )

load semantics .

mod DEFINITION is
    pr REW-RELATION .
    subsort Float < Info .
    subsort Nat < Agent .

    var AG          : Agent .
    var F           : Float .
    var SN          : SetOpinion .
    vars SE EDGES   : SetEdge .
    vars STEPS COMM : Nat .
    
    eq opinion(AG, < nodes: (< AG : F >, SN) ; edges: SE >  in step: STEPS comm: COMM strat: EDGES) = F .
    eq opinion(F) = F .
endm

mod DEGROOT is
    pr DEFINITION .

    vars AG AG' AG'' : Agent .
    vars SE EDGES    : SetEdge .
    var SO           : SetOpinion .
    vars STEPS COMM  : Nat .
    var NETWORK      : Network .
    vars SCOUNT SUMW : Float .
    vars PHI PHI' W  : Float .

    op deGroot : SetEdge -> SetSetEdge .
    eq deGroot(SE) = SE .

    op update-degroot : State SetEdge Agent -> Float .
    ceq update-degroot(NETWORK  in step: STEPS comm: COMM strat: EDGES, SE, AG) = 
        if SCOUNT == 0.0 then opinion(AG, NETWORK  in step: STEPS comm: COMM strat: EDGES)
            else opinion(AG,  NETWORK  in step: STEPS comm: COMM strat: EDGES) + (SUMW / SCOUNT)
        fi
        if 
            SCOUNT  := sum-W(AG, SE) /\ 
            SUMW := prod-diff(AG, nodes(NETWORK  in step: STEPS comm: COMM strat: EDGES ), SE) .

    op prod-diff : Agent SetOpinion SetEdge -> Float .
    op prod-diff : Agent SetOpinion SetEdge Float -> Float .
    eq prod-diff(AG, SO, SE) = prod-diff(AG, SO, SE, 0.0) .
    eq prod-diff(AG, SO, empty, SUMW) = SUMW .
    eq prod-diff(AG, (SO, < AG : PHI >, < AG' :  PHI' >), ( < (AG', AG ) :  W  >, SE), SUMW) = 
        prod-diff(AG, (SO, < AG : PHI >, < AG' : PHI' >), SE, SUMW + (PHI' - PHI) * W) .
    eq prod-diff(AG, SO, ( < (AG' , AG'') :  W  >, SE), SUMW) = 
        prod-diff(AG, SO, SE, SUMW) [owise] .

    op sum-W : Agent SetEdge -> Float .
    op sum-W : Agent SetEdge Float -> Float .
    eq sum-W(AG, SE) = sum-W(AG, SE, 0.0) .
    eq sum-W(AG, empty, SUMW) = SUMW .
    eq sum-W(AG, ( < (AG', AG ) :  W  >, SE), SUMW) = 
        sum-W(AG, SE , SUMW + W ) .
    eq sum-W(AG, ( < (AG' , AG'') :  W  >, SE), SUMW) = 
        sum-W(AG, SE, SUMW) [owise] .
endm

mod GOSSIP is
    pr DEFINITION .

    vars AG AG'     : Agent .
    vars SE EDGES   : SetEdge .
    vars STEPS COMM : Nat .
    var NETWORK     : Network .
    vars PHI PHI' W : Float .
    var STR         : SetSetEdge .
    var E           : Edge .

    op gossip  : SetEdge            -> SetSetEdge [memo] .
    op $gossip : SetEdge SetSetEdge -> SetSetEdge .

    eq gossip(SE) = $gossip(SE, mt) .
    eq $gossip(empty, STR) = STR .
    eq $gossip((E, SE), STR) = $gossip(SE, (STR ; E)) .


    op update-gossip : State SetEdge Agent -> Float .
    ceq update-gossip(NETWORK  in step: STEPS comm: COMM strat: EDGES, < (AG' , AG) : W >, AG) = 
      opinion(AG, NETWORK  in step: STEPS comm: COMM strat: EDGES) + W * (PHI' - PHI)
    if
      PHI  := opinion(AG, NETWORK  in step: STEPS comm: COMM strat: EDGES) /\
      PHI' := opinion(AG', NETWORK  in step: STEPS comm: COMM strat: EDGES) .
    eq update-gossip(NETWORK  in step: STEPS comm: COMM strat: EDGES, SE, AG) = 
      opinion(AG, NETWORK  in step: STEPS comm: COMM strat: EDGES) [owise] .
endm

mod HYBRID is 
    pr DEGROOT .

    var STATE      : State .
    var AG         : Agent .
    var E          : Edge .
    vars STR STR' : SetSetEdge .
    var SE         : SetEdge .
    var N          : Nat .

    op mt : -> SetSetEdge [ctor] .

    op hybrid  : SetEdge -> SetSetEdge [memo] .
    eq hybrid(empty) = mt .
    ceq hybrid((E, SE)) = 
        STR' ; add(E, STR') 
    if STR' := hybrid(SE) .

    op add  : Edge SetSetEdge            -> SetSetEdge .
    op $add : Edge SetSetEdge SetSetEdge -> SetSetEdge .
    eq add(E, STR) = $add(E, STR, mt) .
    eq $add(E, mt, STR') = E ; STR' .
    eq $add(E, (SE ; STR), STR') = $add(E, STR, STR' ; (E, SE)) .

    op filter= : Nat SetSetEdge -> SetSetEdge .
    eq filter=(N, mt) = mt .
    eq filter=(N, SE ; STR) = if | SE | == N then SE else mt fi ; filter=(N, STR) .
    op filter>= : Nat SetSetEdge -> SetSetEdge .
    eq filter>=(N, mt) = mt .
    eq filter>=(N, SE ; STR) = if | SE | >= N then SE else mt fi ; filter>=(N, STR) .
    op filter<= : Nat SetSetEdge -> SetSetEdge .
    eq filter<=(N, mt) = mt .
    eq filter<=(N, SE ; STR) = if | SE | <= N then SE else mt fi ; filter<=(N, STR) .

    op update-hybrid : State SetEdge Agent -> Float .
    eq update-hybrid(STATE, SE, AG) = update-degroot(STATE, SE, AG) .
    -----------------------------------------------------------------
    vars AG'         : Agent .
    var SO           : SetOpinion .
    var F F'         : Float .
    vars SA SA' SA'' : SetAgent .
    ---var SSA          : SetSetAgent .

    --- Operación que devuelve la excentricidad de un nodo
    op eccentricity : Agent SetEdge -> Float .
    op eccentricity : SetAgent SetEdge SetAgent SetAgent Float -> Float .
    eq eccentricity(AG, SE) = eccentricity((AG), SE, incidents(SE), (AG), 0.0) .
    eq eccentricity(SA', SE, SA', SA, F) = F .
    eq eccentricity((AG, SA), (< (AG , AG') : F' >, SE), SA', SA'', F) = 
        eccentricity((AG, SA), SE, SA', (SA'', AG'), F) .
    eq eccentricity(SA, SE, SA', SA'', F) =
        eccentricity((SA, SA''), SE, SA', SA'', F + 1.0) .

    --- Operación que devuelve las excentricidades de los nodos de un grafo
    op eccentricities : SetOpinion SetEdge -> SetOpinion .
    eq eccentricities((< AG : F >, SO), SE) = (< AG : eccentricity(AG, SE)>, eccentricities(SO, SE)) .
    eq eccentricities(empty, SE) = empty .

    --- Operación que devuelve el/un nodo central de un grafo
    op center : SetOpinion SetEdge -> Agent [memo] .
    eq center(SO, SE) = centro .
    ---op center : SetOpinion Opinion -> Agent .
    ---eq center(SO, SE) = center(eccentricities(SO, SE), < 40 : 10000.0 >) .
    ---eq center((< AG : F >, SO), < AG' : F' >) =
    ---    if F < F' then center(SO, (< AG : F >)) 
    ---    else center(SO, (< AG' : F' >)) fi .
    ---eq center(empty, (< AG : F >)) = AG .

    --- Operación que devuelve el/un nodo central de un grafo con su valor
    op center2 : SetOpinion SetEdge -> Opinion [memo] .
    op center2 : SetOpinion Agent -> Opinion [memo] .
    eq center2(SO, SE) = center2(SO, centro) .
    eq center2((< AG : F >, SO), AG) = < AG : F > .
    ---eq center2(SO, SE) = center2(SO, center(SO, SE)) .

    --- Operación que dado un nodo y una capa devuelve los nodos que pertenecen a esa capa 
    op layer : Agent Nat SetEdge -> SetAgent .
    op layer : SetAgent Nat SetEdge SetAgent SetAgent -> SetAgent .
    eq layer(AG, N, SE) = layer((AG), N, SE, empty, (AG)) .
    eq layer(SA, 0, SE, SA', SA'') = SA'' .
    eq layer((AG, SA), N, (< (AG , AG') : F' >, SE), SA', SA'') =
        layer((AG, SA), N, SE, (SA', AG'), SA'') .
    eq layer(SA, N, SE, SA', SA'') =
        layer((SA, SA'), N - 1, SE, empty, SA' \ SA) .
    
    --- Operación que devuelve las aristas que afectan a un centro y a los nodos de una de sus capas
    op edgesCenterLayer : SetEdge State Nat -> SetEdge [memo] .
    op edgesCenterLayer : SetEdge SetAgent Nat -> SetEdge [memo] .
    eq edgesCenterLayer(SE, STATE, N) = edgesCenterLayer(SE, center(nodes(STATE), SE), N) .
    ---eq edgesCenterLayer(SE, STATE, N) = edgesCenterLayer(SE, centro, N) .
    eq edgesCenterLayer(SE, (AG, SA), N) = edgesByAgents(SE, (AG, layer(AG, N, SE))) .

    --- Operación que dado un nodo devuelve los nodos que ya están en consenso con él
    op nearbyAgents : Opinion SetOpinion -> SetAgent [memo] .
    eq nearbyAgents(< AG : F >, (< AG' : F' >, SO)) =
        if abs(F - F') < EPSILON then (AG', nearbyAgents(< AG : F >, SO))
        else (nearbyAgents(< AG : F >, SO)) fi .
    eq nearbyAgents(< AG : F >, empty) = empty .

    --- Operación que dado un conjunto de nodos y de aristas devuelve las aristas que
    --- afectan a esos nodos.
    op edgesByAgents : SetEdge SetAgent -> SetEdge [memo] .
    eq edgesByAgents((< (AG' , AG) : F >, SE), (AG, SA)) =
        (< (AG' , AG) : F >, edgesByAgents(SE, (AG, SA))) .
    eq edgesByAgents(SE, (AG, SA)) = edgesByAgents(SE, SA) .
    eq edgesByAgents(SE, empty) = empty .
    
    --- Estrategia que busca si una capa entera y el centro se pueden
    --- acercar a un punto en el primer paso
    op s1 : SetEdge State -> SetEdge [memo] .
    eq s1(SE, STATE) =
        if steps(STATE) == 0 then hybrid(edgesCenterLayer(SE, STATE, capa))
        else hybrid(SE \ edgesByAgents(SE, nearbyAgents(center2(nodes(STATE), SE), nodes(STATE)))) fi .

    op centro : -> Agent .
    op capa : -> Nat .

endm

    ---op centros : -> SetAgent .
    ---sort SetSetAgent .
    ---subsort NeSetAgent < SetSetAgent .
    ---op mta : -> SetSetAgent [ctor] .
    ---op _;_ : SetSetAgent SetSetAgent -> SetSetAgent [ctor assoc comm id: mta] .

    ---op getCenter  : SetAgent            -> SetSetAgent [memo] .
    ---op $getCenter : SetAgent SetSetAgent -> SetSetAgent .

    ---eq getCenter(SA) = $getCenter(SA, mta) .
    ---eq $getCenter(empty, SSA) = SSA .
    ---eq $getCenter((AG, SA), SSA) = $getCenter(SA, (SSA ; AG)) .